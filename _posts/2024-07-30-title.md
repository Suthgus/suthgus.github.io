---
layout: post
title:  "데이터 다루기"
date : 2024-07-29 00:25:20 +0700
---

# 02 데이터 다루기
## 2-1 훈련 세트와 테스트 세트

이전 포스팅에서는 k-최근접 이웃 알고리즘을 사용해서 도미와 빙어를 분류하였다.    
이미 답을 알고있는 상태에서 훈련 후, 같은 데이터를 분류하는 것이기 때문에 정확도가 100%인 결과는 당연한 것이다. 

### 지도학습과 비지도학습    
머신러닝 알고리즘은 지도학습과 비지도 학습으로 나눌 수 있다. 
- *지도학습*: 훈련하기 위한 입력(데이터)와 타깃(정답)이 필요하다. ex) k-최근접 이웃 알고리즘
- 입력과 타깃을 훈련 데이터라고 한다.
- 정답이 있으니 알고리즘이 정답을 맞히는 것을 학습한다.
![image](https://github.com/user-attachments/assets/e819ae01-4439-4f4f-a208-0b83cf490d99)    

- *비지도 학습*: 타깃 없이 입력 데이터만 사용한다. -> 무언가를 맞힐 수 없고, 데이터의 특징을 파악하거나 변형하는데 도움을 준다.

### 훈련세트와 테스트세트    
머신러닝 알고리즘의 성능을 제대로 평가하기 위해서는 훈련 데이터와 평가에 사용하는 데이터가 달라야한다.    
따라서 이미 준비된 데이터를 테스트세트(평가에 사용하는 데이터)와 훈련세트(훈련에 사용하는 데이터)로 나누어 활용한다.     

따라서 이전 포스트에서 훈련에 사용한 데이터를 이용해 이 모델의 정확도를 평가하는 것은 적절하지 않다.    
이를 위해서 훈련 데이터에서 일부를 떼어 내어 테스트 데이터로 사용하도록 하자.    
![image](https://github.com/user-attachments/assets/268a3e66-2285-40d5-9f70-d3e1b418cc2d)    

두 파이썬 리스트를 순회하면서 각 생선의 무게를 하나의 리스트로 담은 2차원 리스트로 만들자.     
![image](https://github.com/user-attachments/assets/2e290b63-3cd3-4f01-aa3e-b515045f3f79)    
이때 하나의 생선 데이터를 샘플이라고 한다. 전체 49개의 샘플에서 35개를 훈련세트로, 나머지 14개를 테스트 데이터로 사용하자.     
![image](https://github.com/user-attachments/assets/c2090726-43b7-422b-a75c-d91da524453e)    

KNeighborsClassifier 클래스를 임포트하고 모델 객체를 만들자.      
![image](https://github.com/user-attachments/assets/512d51c5-d6aa-4edf-b0d4-e30b5265edbb)    
슬라이싱을 이용하여 전체 49개의 샘플에서 35개를 훈련세트로 선택해주고, 나머지 14개를 테스트세트로 선택해주자.    
![image](https://github.com/user-attachments/assets/da1eaf5f-ba28-4706-a5e2-983214758efd)     

훈련세트로 fit() 메서드를 호출해 모델을 훈련하고, 테스트 세트로 score() 메서드를 호출해 평가해보자.    
![image](https://github.com/user-attachments/assets/ef94b19a-1671-4e06-9869-1e760bfaca44)
정확도가 0.0인 것을 확인할 수 있다.    
무엇을 잘못한 것일까???

### 샘플링 편향      
훈련세트와 테스트세트를 나눌 때 마지막 14개를 테스트세트로 했다.    
따라서 훈련세트에 빙어가 하나도 들어가지 않았기 때문에 올바른 분류를 하지 못한 것이다. 
이렇게 훈련세트와 테스트세트에 샘플이 골고루 섞이지 않고, 샘플링이 한쪽으로 치우쳤다면 *샘플링 편향*이라고 한다. 
훈련세트와 테스트세트 나누려면 도미와 빙어가 골고루 섞이도록 해야한다.      
이 작업을 간편하게 처리하기 위해서 넘파이 라이브러리를 이용한다.    

### 넘파이    
- 파이썬의 대표적인 배열(array) 라이브러리이다.    
- 고차원의 배열을 손쉽게 만들고 조작할 수 있는 간편한 도구를 많이 제공한다.     
![image](https://github.com/user-attachments/assets/5d554d68-9e4b-45d6-b844-b1a73bb75db0)     
- 시작점이 왼쪽 위이다. (보통의 xy좌표계는 왼쪽 아래에서 시작)

생선 데이터(파이썬 리스트)를 2차원 넘파이 배열로 변환해보자. : array()함수에 파이썬 리스트를 전달하면 됨   
![image](https://github.com/user-attachments/assets/c0ad9ece-7904-47ed-9134-99c4760ff098)     
![image](https://github.com/user-attachments/assets/17155e1a-9a1d-490c-80dd-7403022351e1)      
![image](https://github.com/user-attachments/assets/96760e1a-b53c-40bd-bc4f-48b63536e79f)     
넘파이는 배열의 차원을 구분하기 쉽도록 행과 열을 가지런히 출력한다.     
![image](https://github.com/user-attachments/assets/17a50a1f-a82a-4215-a05e-4587b3dc9659)     

생선의 데이터를 넘파이 배열로 준비했으므로, 이 배열에서 랜덤하게 샘플을 선택해 훈련세트와 테스트세트로 만들어보자.    
여기서 주의할 점은 input_arr과 target_arr에서 같은 위치는 함께 선택되어야 한다는 점이다.     
![image](https://github.com/user-attachments/assets/e6549ff5-6e1d-40d6-9393-7bad27490f01)     

넘파이 arrange()함수를 사용하여 0부터 48까지(총 49개) 1씩 증가하는 인덱스를 만든 후 인덱스를 섞어보자.    
![image](https://github.com/user-attachments/assets/447d84ff-5593-4fa1-a3f9-3461bf0ed1b2)    
![image](https://github.com/user-attachments/assets/267d1315-0184-4031-9468-3d551a8fcd01)    
0부터 48까지 정수가 잘 섞인 것을 확인할 수 있다. 이제 이 섞인 인덱스를 사용해 전체 데이터를 훈련세트와 테스트세트로 나누어 보자.    
- 배열 인덱싱: 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있음    
- ex) input_arr에서 2번째와 네번째 샘플을 선택해서 출력해보자    
-  ![image](https://github.com/user-attachments/assets/3748452d-14d7-4d1b-ae3b-77d0b430e4b5)

앞서 만든 index 배열의 처음 35개를 훈련세트로 만들어보자.    
![image](https://github.com/user-attachments/assets/cbe15a8b-0854-45de-999f-30feb03e5d00)    
이제 나머지 14개를 테스트세트로 만들어보자.     
![image](https://github.com/user-attachments/assets/f4d6992b-b320-41ac-8ac5-95b5ace22190)    
모든 데이터가 준비되었다.     

훈련세트와 테스트세트에 도미와 빙어가 잘 섞여있는지 산점도를 그려보자     
![image](https://github.com/user-attachments/assets/e102762f-167b-48c3-b2f1-831a1d65f119)    
파란색이 훈련세트이고, 주황색이 테스트세트이다. 양쪽에 도미와 빙어가 모두 섞여 있는 것을 확인할 수 있다.     
이제 앞서 만든 훈련세트와 테스트세트로 모델 훈련을 시켜보자.    
fit()메서드를 실행할 때마다 KNeighborsClassifier 클래스의 객체는 학습한 모든 것을 잃어버린다.    
이전 모델을 그대로 두고 싶다면 KNeighborsClassifier 클래스 객체를 새로 만들어야하지만, 여기에서는 이전에 만든 kn 객체를 그대로 사용하도록 하자.    
![image](https://github.com/user-attachments/assets/7f532afd-e435-4dcb-a3c8-277c4efed956)    
![image](https://github.com/user-attachments/assets/d73ea03d-79d4-405d-be9d-5947a9575ee2)    
인덱스를 섞어서 만든 train 데이터로 모델을 훈련시킨 후, test 데이터로 테스트 한 결과, 100%의 정확도를 달성하였다.    
![image](https://github.com/user-attachments/assets/34aefc4b-6c55-4c05-a443-5f5c81a578c1)    
![image](https://github.com/user-attachments/assets/d848f8d3-bbdb-4249-9ad3-dced3c5d8b8f)     
predict() 메서드로 테스트 세트의 예측 결과와 실제 타깃을 확인한 결과도 일치하는 것을 확인하였다.   
- 두 결과값은 array()로 감싸있는 것을 볼 수 있다. 이 값은 넘파이 배열을 의미한다.
- 사실, 사이킷런 모델의 입력과 출력은 모두 넘파이 배열이다.    

